"""
API tests for {domain} endpoints.

Tests full HTTP stack with TestClient.

USAGE:
1. Copy this file to tests/api/test_{domain}_api.py
2. Replace {Domain} with capitalized domain name (e.g., Item)
3. Replace {domain} with lowercase domain name (e.g., item)
4. Replace {domain}s with plural form (e.g., items)
5. Replace {entity} with entity name (e.g., item)
6. Adjust endpoint paths to match your router
7. Add/remove tests based on your API endpoints
"""

import pytest
from fastapi.testclient import TestClient

from app.{domain}.repository import {Domain}Repository
from app.main import app
from app.shared.dependencies import get_{domain}_repository


@pytest.fixture
def client(test_db_session):
    """Create a test client with test database session."""

    def override_get_{domain}_repository():
        return {Domain}Repository(test_db_session)

    app.dependency_overrides[get_{domain}_repository] = override_get_{domain}_repository
    yield TestClient(app)
    app.dependency_overrides.clear()


@pytest.mark.api
class TestGet{Domain}sEndpoint:
    """Test GET /{domain}s endpoint."""

    def test_get_{domain}s_when_empty_returns_empty_list(self, client):
        """Test getting {domain}s when none exist."""
        # Act
        response = client.get("/{domain}s")

        # Assert
        assert response.status_code == 200
        assert response.json() == []

    def test_get_{domain}s_returns_all_{domain}s(self, client):
        """Test getting all {domain}s."""
        # Arrange - Create {domain}s
        client.post("/{domain}s", json={"name": "{Domain} 1"})
        client.post("/{domain}s", json={"name": "{Domain} 2"})

        # Act
        response = client.get("/{domain}s")

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert any({entity}["name"] == "{Domain} 1" for {entity} in data)
        assert any({entity}["name"] == "{Domain} 2" for {entity} in data)


@pytest.mark.api
class TestGet{Domain}ByIdEndpoint:
    """Test GET /{domain}s/{{{entity}_id}} endpoint."""

    def test_get_{entity}_when_exists_returns_{entity}(self, client):
        """Test getting an existing {entity}."""
        # Arrange
        create_response = client.post(
            "/{domain}s",
            json={"name": "Test {Domain}"}
        )
        {entity}_id = create_response.json()["id"]

        # Act
        response = client.get(f"/{domain}s/{{entity}_id}")

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == {entity}_id
        assert data["name"] == "Test {Domain}"

    def test_get_{entity}_when_not_exists_returns_404(self, client):
        """Test getting a non-existent {entity}."""
        # Act
        response = client.get("/{domain}s/999")

        # Assert
        assert response.status_code == 404
        assert "detail" in response.json()


@pytest.mark.api
class TestCreate{Domain}Endpoint:
    """Test POST /{domain}s endpoint."""

    def test_create_{entity}_with_valid_data_returns_201(self, client):
        """Test creating a {entity} with valid data."""
        # Arrange
        request_data = {
            "name": "New {Domain}",
            # Add other required fields
        }

        # Act
        response = client.post("/{domain}s", json=request_data)

        # Assert
        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "New {Domain}"
        assert "id" in data
        assert "created_at" in data

    def test_create_{entity}_without_required_field_returns_422(self, client):
        """Test creating a {entity} without required field."""
        # Arrange
        request_data = {
            # Missing required 'name' field
        }

        # Act
        response = client.post("/{domain}s", json=request_data)

        # Assert
        assert response.status_code == 422

    def test_create_{entity}_with_invalid_field_returns_422(self, client):
        """Test creating a {entity} with invalid field value."""
        # Arrange
        request_data = {
            "name": "Test",
            "price": -10.0  # Example: invalid negative price
        }

        # Act
        response = client.post("/{domain}s", json=request_data)

        # Assert
        assert response.status_code == 422

    def test_create_{entity}_returns_all_expected_fields(self, client):
        """Test created {entity} contains all expected fields."""
        # Arrange
        request_data = {
            "name": "Complete {Domain}",
            # Add all fields
        }

        # Act
        response = client.post("/{domain}s", json=request_data)

        # Assert
        assert response.status_code == 201
        data = response.json()
        assert "id" in data
        assert "name" in data
        assert "created_at" in data
        # Assert other expected fields


@pytest.mark.api
class TestUpdate{Domain}Endpoint:
    """Test PUT /{domain}s/{{{entity}_id}} endpoint."""

    def test_update_{entity}_when_exists_returns_200(self, client):
        """Test updating an existing {entity}."""
        # Arrange - Create {entity}
        create_response = client.post(
            "/{domain}s",
            json={"name": "Original"}
        )
        {entity}_id = create_response.json()["id"]

        # Act
        response = client.put(
            f"/{domain}s/{{entity}_id}",
            json={"name": "Updated"}
        )

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["name"] == "Updated"

    def test_update_{entity}_with_partial_data_updates_only_provided_fields(self, client):
        """Test partial update only changes specified fields."""
        # Arrange
        create_response = client.post(
            "/{domain}s",
            json={"name": "Original", "description": "Original Desc"}
        )
        {entity}_id = create_response.json()["id"]

        # Act - Only update name
        response = client.put(
            f"/{domain}s/{{entity}_id}",
            json={"name": "Updated Name"}
        )

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert data["name"] == "Updated Name"
        assert data["description"] == "Original Desc"  # Unchanged

    def test_update_{entity}_when_not_exists_returns_404(self, client):
        """Test updating a non-existent {entity}."""
        # Act
        response = client.put(
            "/{domain}s/999",
            json={"name": "Updated"}
        )

        # Assert
        assert response.status_code == 404

    def test_update_{entity}_with_invalid_data_returns_422(self, client):
        """Test updating with invalid field value."""
        # Arrange
        create_response = client.post(
            "/{domain}s",
            json={"name": "Original"}
        )
        {entity}_id = create_response.json()["id"]

        # Act
        response = client.put(
            f"/{domain}s/{{entity}_id}",
            json={"price": -10.0}  # Example: invalid value
        )

        # Assert
        assert response.status_code == 422


@pytest.mark.api
class TestDelete{Domain}Endpoint:
    """Test DELETE /{domain}s/{{{entity}_id}} endpoint."""

    def test_delete_{entity}_when_exists_returns_204(self, client):
        """Test deleting an existing {entity}."""
        # Arrange
        create_response = client.post(
            "/{domain}s",
            json={"name": "To Delete"}
        )
        {entity}_id = create_response.json()["id"]

        # Act
        response = client.delete(f"/{domain}s/{{entity}_id}")

        # Assert
        assert response.status_code == 204

        # Verify {entity} is gone
        get_response = client.get(f"/{domain}s/{{entity}_id}")
        assert get_response.status_code == 404

    def test_delete_{entity}_when_not_exists_returns_404(self, client):
        """Test deleting a non-existent {entity}."""
        # Act
        response = client.delete("/{domain}s/999")

        # Assert
        assert response.status_code == 404


@pytest.mark.api
class Test{Domain}Flows:
    """Test complete user journeys."""

    def test_complete_crud_flow(self, client):
        """Test complete create-read-update-delete flow."""
        # Create
        create_response = client.post(
            "/{domain}s",
            json={"name": "Test {Domain}"}
        )
        assert create_response.status_code == 201
        {entity}_id = create_response.json()["id"]

        # Read
        get_response = client.get(f"/{domain}s/{{entity}_id}")
        assert get_response.status_code == 200
        assert get_response.json()["name"] == "Test {Domain}"

        # Update
        update_response = client.put(
            f"/{domain}s/{{entity}_id}",
            json={"name": "Updated {Domain}"}
        )
        assert update_response.status_code == 200
        assert update_response.json()["name"] == "Updated {Domain}"

        # Delete
        delete_response = client.delete(f"/{domain}s/{{entity}_id}")
        assert delete_response.status_code == 204

        # Verify deleted
        final_get = client.get(f"/{domain}s/{{entity}_id}")
        assert final_get.status_code == 404

    def test_create_multiple_and_list_flow(self, client):
        """Test creating multiple {domain}s and listing them."""
        # Create multiple
        client.post("/{domain}s", json={"name": "{Domain} 1"})
        client.post("/{domain}s", json={"name": "{Domain} 2"})
        client.post("/{domain}s", json={"name": "{Domain} 3"})

        # List
        response = client.get("/{domain}s")
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 3


# Add search/filter tests if your API supports it
@pytest.mark.api
class TestSearch{Domain}sEndpoint:
    """Test GET /{domain}s/search endpoint."""

    def test_search_{domain}s_with_filters_returns_matches(self, client):
        """Test searching {domain}s with filters."""
        # Arrange
        client.post("/{domain}s", json={"name": "Laptop Pro"})
        client.post("/{domain}s", json={"name": "Laptop Air"})
        client.post("/{domain}s", json={"name": "Desktop"})

        # Act
        response = client.get("/{domain}s/search?name=Laptop")

        # Assert
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert all("Laptop" in {entity}["name"] for {entity} in data)

    def test_search_{domain}s_with_no_matches_returns_empty(self, client):
        """Test searching with no matches."""
        # Arrange
        client.post("/{domain}s", json={"name": "{Domain}"})

        # Act
        response = client.get("/{domain}s/search?name=Nonexistent")

        # Assert
        assert response.status_code == 200
        assert response.json() == []
